import test from 'ava'
import cloneDeep from 'clone-deep'
import delay from 'delay'
import fs from 'fs-extra'
import { generateDefinition } from 'fts'
import { createValidator } from 'fts-validator'
import getPort from 'get-port'
import globby from 'globby'
import got from 'got'
import jsf from 'json-schema-faker'
import path from 'path'
import pify from 'pify'
import qs from 'qs'
import seedrandom from 'seedrandom'
import tempy from 'tempy'
import * as HTTP from '.'

const fixtures = globby.sync('./fixtures/http-request.ts')
// const fixtures = globby.sync('./fixtures/**/*.{js,ts}')

jsf.option({
  alwaysFakeOptionals: true,
  // make values generated by json-schema-faker deterministic
  random: seedrandom('NzYxNDdlNjgxYzliN2FkNjFmYjBlMTI5')
})

// 1x1 png from http://www.1x1px.me/
const image =
  'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEX/TQBcNTh/AAAAAXRSTlPM0jRW/QAAAApJREFUeJxjYgAAAAYAAzY3fKgAAAAASUVORK5CYII='

for (const fixture of fixtures) {
  const { name, dir } = path.parse(fixture)
  const testConfigPath = path.join(process.cwd(), dir, 'config.json')

  test.serial(name, async (t) => {
    let testConfig = {
      get: true,
      post: true
    }

    if (fs.pathExistsSync(testConfigPath)) {
      testConfig = {
        ...testConfig,
        ...require(testConfigPath)
      }
    }

    const outDir = tempy.directory()
    const definition = await generateDefinition(fixture, {
      compilerOptions: {
        outDir
      },
      emit: true
    })
    t.truthy(definition)

    const isRawHttpRequest = !!definition.params.http
    const isRawHttpResponse = !!definition.returns.http
    const hasContext = !!definition.params.context
    const supportsRest = definition.params.schema.additionalProperties
    const validator = createValidator()
    const paramsDecoder = validator.decoder(definition.params.schema)
    const returnsEncoder = validator.encoder(definition.returns.schema)

    const jsFilePath = path.join(outDir, `${name}.js`)
    const handler = HTTP.createHttpHandler(definition, jsFilePath, {
      debug: true
    })
    t.is(typeof handler, 'function')

    const port = await getPort()
    const server = await HTTP.createHttpServer(handler, port)
    const url = `http://localhost:${port}`

    const params = await jsf.resolve(definition.params.schema)
    const paramsLocal = cloneDeep(params)
    paramsDecoder(paramsLocal)
    t.is(paramsDecoder.errors, null)

    let paramsLocalArray: any[] = []
    if (isRawHttpRequest) {
      if (definition.params.order.length) {
        paramsLocalArray = [Buffer.from(image, 'base64')]
      }

      if (hasContext) {
        paramsLocalArray.push({
          contentType: 'image/png'
        })
      }
    } else {
      paramsLocalArray = definition.params.order.map((key) => paramsLocal[key])

      if (supportsRest) {
        const additionalProperty = 'Hello, World!'
        params.additionalProperty = additionalProperty
        paramsLocalArray.push(['additionalProperty', additionalProperty])
      }
    }

    const func = HTTP.requireHandlerFunction(definition, jsFilePath)

    const result = await Promise.resolve(func(...paramsLocalArray))
    const expected = { result }
    if (!isRawHttpResponse) {
      returnsEncoder(expected)
      t.is(returnsEncoder.errors, null)
    } else {
      expected.result = (result.body || Buffer.from('')).toString()
    }
    const expectedEncoded = JSON.parse(JSON.stringify(expected))
    console.log({ name, params, port, expected })

    // test GET request with params as a query string
    // note: some fixtures will not support this type of encoding
    if (!definition.params.http && testConfig.get) {
      const query = qs.stringify(params)
      const temp: any = { query }
      if (!isRawHttpResponse) {
        temp.json = true
      }
      const responseGET = await got(url, temp)
      validateResponseSuccess(responseGET, 'GET', expectedEncoded)
    }

    // test POST request with params as a json body object
    if (testConfig.post) {
      const temp: any = { body: params }
      if (isRawHttpRequest) {
        temp.body = Buffer.from(image, 'base64')
        temp.headers = {
          'Content-type': 'image/png'
        }
      } else if (isRawHttpResponse) {
        temp.body = JSON.stringify(params)
        temp.headers = {
          'Content-type': 'application/json'
        }
      } else {
        temp.json = true
      }
      const responsePOST = await got.post(url, temp)
      validateResponseSuccess(responsePOST, 'POST', expectedEncoded)
    }

    await pify(server.close.bind(server))()
    await delay(500)
    await fs.remove(outDir)

    function validateResponseSuccess(
      res: got.Response<object>,
      label: string,
      expected: any
    ) {
      console.log({
        body: res.body,
        label,
        statusCode: res.statusCode
      })
      t.is(res.statusCode, 200)
      const response = { result: res.body as any }

      if (result === undefined || result === null) {
        if (response.result === '') {
          response.result = result
        }
      }

      const responseEncoded = JSON.parse(JSON.stringify(response))
      t.deepEqual(responseEncoded, expected)
    }
  })
}
